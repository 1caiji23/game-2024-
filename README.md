# 日志

‍

### 项目背景与目标

本次日志记录的是一款名为“飞船宇宙旅行”的小游戏开发过程，这是一款以探索宇宙为主题的2D游戏。玩家将操控一艘飞船在充满陨石和未知危险的太空中航行，通过躲避障碍物、到达目标地点来体验宇宙冒险的乐趣。游戏的核心玩法围绕飞船的移动、碰撞检测以及关卡设计展开，同时注重界面设计和操作体验的优化，旨在为玩家提供流畅且富有沉浸感的游戏体验。

团队由三名成员组成，分别是刘润杰、汪世伦和唐铭阳，

​​​![image](assets/image-20250326130653-iiqzv9s.png)

各自负责不同的开发模块。刘润杰主要负责实现游戏核心功能，包括飞船的移动逻辑、碰撞检测以及死亡后果等视觉效果的开发；汪世伦专注于关卡设计和游戏逻辑的优化，确保游戏难度适中且具有挑战性；唐铭阳则负责游戏的界面设计和用户体验改进，从主菜单到游戏内HUD，再到控制方式的调整，力求让玩家感受到直观而舒适的操作体验。

在开发过程中，团队采用了分阶段推进的方式，逐步完善游戏的各项功能。第一阶段的重点是搭建基础框架，包括飞船的移动功能、关卡的基本结构以及游戏界面的设计；第二阶段则进一步丰富游戏内容，如添加传送门、随机生成陨石、优化控制方式等；第三阶段致力于解决技术难点，例如碰撞检测的实现、音效的集成以及代码调试。通过明确分工与紧密协作，团队希望在最终版本中呈现出一款兼具趣味性和技术性的宇宙冒险游戏。

### 日志（一）：初步开发进展与功能实现

刘润杰：飞船移动

汪世伦：关卡设计

唐铭阳：界面设计

在项目的初期阶段，团队成员各司其职，完成了多项基础功能的开发工作，为后续的游戏构建奠定了坚实的基础。首先，刘润杰成功实现了飞船的移动功能，这是整个游戏的核心机制之一。通过编写简洁高效的代码，使飞船能够根据玩家输入的方向键进行上下左右的平滑移动。这一功能的实现不仅验证了物理引擎的可行性，也为后续的碰撞检测和特效设计提供了重要的技术支撑。此外，刘润杰还对飞船的移动速度进行了细致调整，确保玩家在不同场景下的操作既流畅又不失挑战性。

```cpp
//initgraph(1700, 1000);

// 绘制基础界面
line(0, 800, 1700, 800);     // 地面线
line(1200, 0, 1200, 800);    // 分区线
rectangle(200, 850, 1500, 950); // 对话框
int death_counter=0;
step_1();//绘制关卡一

// 加载驾驶图片
IMAGE img;
loadimage(&img, _T("image.png"), 500, 370);
putimage(1200, 430, &img);

// 物理参数
float mg=1.0f;
float x = 0.0f, y = 759.0f;    // 初始位置
float vx = 0.0f, vy = 0.0f;    // 速度矢量
const float acceleration = 1200.0f; // 加速度
const float friction = 0.92f;      // 地面摩擦
const float air_resistance = 0.98f;// 空气阻力
const float max_speed = 600.0f;    // 极限速度
```

|功能模块|代码实现|说明|
| --------------| ------------------------------------------| --------------------------------------------------------------------------------|
|界面初始化|​`//initgraph(1700, 1000);`​|初始化绘图窗口（代码被注释，未实际执行 ）|
|绘制基础界面|​`line(0, 800, 1700, 800);`​ <br /> `line(1200, 0, 1200, 800);`​ <br /> `rectangle(200, 850, 1500, 950);`​|分别绘制地面线、分区线、对话框|
|计数器初始化|​`int death_counter=0;`​|初始化死亡计数器为0|
|关卡绘制|​`step_1();`​|调用函数绘制关卡一|
|图片加载|​`IMAGE img;`​ <br /> `loadimage(&img, _T("image.png"), 500, 370);`​ <br /> `putimage(1200, 430, &img);`​|定义图片对象，加载图片并绘制到指定位置|
|物理参数定义|​`float mg=1.0f;`​ <br /> `float x = 0.0f, y = 759.0f;`​ <br /> `float vx = 0.0f, vy = 0.0f;`​ <br /> `const float acceleration = 1200.0f;`​ <br /> `const float friction = 0.92f;`​ <br /> `const float air_resistance = 0.98f;`​ <br /> `const float max_speed = 600.0f;`​|分别定义质量、初始位置、速度矢量、加速度、地面摩擦系数、空气阻力系数、极限速度|

与此同时，汪世伦着手进行了关卡设计，初步设定了关卡的基本结构和难度梯度。他采用了一种渐进式的难度提升策略，即随着关卡的推进，陨石的数量和移动速度逐渐增加，同时引入一些特殊障碍物来提高游戏的复杂性。为了确保关卡设计的合理性，汪世伦还制作了一个简单的测试环境，用于评估玩家在不同难度下的表现。这一过程不仅帮助团队明确了关卡的核心元素，还为后续优化提供了宝贵的参考数据。

![image](assets/image-20250319171721-7p4ez21.png)

在界面设计方面，唐铭阳完成了游戏界面的初步搭建，包括主菜单和游戏内HUD的设计。主菜单采用了简洁明快的风格，包含“开始游戏”、“设置”和“退出”三个选项，每个按钮都经过精心调整以确保点击区域清晰易用。游戏内HUD则包含了飞船的生命值显示、得分计数器以及当前关卡信息，所有元素均以半透明的形式呈现，避免干扰玩家的游戏视野。此外，唐铭阳还特别注重界面的响应速度，确保玩家在切换菜单或查看信息时不会感到延迟或卡顿。

![image](assets/image-20250319171741-7kbieff.png)

总体而言，第一阶段的工作成果显著，团队成员在各自领域内的努力为游戏的整体框架打下了扎实的基础。飞船的移动功能、关卡的基本结构以及界面设计的成功实现，不仅展示了团队的技术实力，也为接下来的功能扩展和技术优化铺平了道路。

### 日志（二）：功能优化与交互改进

刘润杰：死亡粒子效果

汪世伦：陨石随机效果

唐铭阳：键盘改为鼠标实现

问题：音效暂时未完成，代码连接暂时错误

在第二阶段的开发中，团队成员继续深化各自负责的模块，通过一系列创新和优化进一步提升了游戏的可玩性和用户体验。刘润杰在这一阶段实现了飞船死亡时的效果，为游戏增添了视觉冲击力。当飞船与陨石发生碰撞时会产生特殊效果，这种动态的表现不仅增强了游戏的沉浸感，也让玩家更加直观地感受到失败的后果。刘润杰通过调整颜色、大小和持续时间，确保了效果既不过于夸张也不显得单调，从而在视觉上达到了平衡。

![image](assets/image-20250319171904-djllgg8.png)

与此同时，汪世伦为游戏增加了陨石的随机生成效果，这一功能极大地提升了游戏的挑战性和不可预测性。他设计了一套复杂的算法，使陨石能够在屏幕的不同位置以不同的速度和方向出现，从而迫使玩家始终保持高度警觉。为了防止陨石生成过于密集或稀疏，汪世伦还加入了动态调节机制，根据当前关卡的难度和玩家的表现实时调整陨石的数量和分布。这一改进不仅让游戏更具吸引力，也为后续关卡设计提供了更多的可能性。

![屏幕截图 2025-03-19 171936](assets/屏幕截图%202025-03-19%20171936-20250319172010-1ipb9pb.png)

在用户交互方面，唐铭阳将控制方式从键盘改为鼠标，这一改动显著提升了操作的直观性。他重新设计了飞船的移动逻辑，使玩家可以通过鼠标指针的位置直接控制选项，而无需频繁切换按键。这种基于鼠标的控制方式优化了菜单选择，还提高了操作的精准度，尤其适合需要快速反应的场景。

![image](assets/image-20250319171922-9zwghhw.png)

尽管这些改进显著提升了游戏的质量，但团队仍面临一些亟待解决的问题。首先，音效尚未完成，这使得游戏在关键时刻缺乏听觉反馈，影响了整体的沉浸感。其次，代码连接存在错误，导致部分功能在特定情况下无法正常运行。这些问题需要进一步调试和优化，以确保游戏的稳定性和完整性。

### 日志（三）：功能完善与体验优化

刘润杰：拼接

汪世伦：碰撞

唐铭阳：背景音乐

在第三阶段的开发中，团队成员集中精力解决了多个关键问题，并对游戏进行了全面优化，为最终版本的发布做好了准备。刘润杰成功完成了飞船与陨石的碰撞检测和响应机制，这是游戏逻辑的核心部分之一。

```cpp
// 函数声明
void DrawButton(Button* btn);
bool CheckMouse(Button* btn);
void ShowStory();
void ShowLevelSelection(int* level);
void HideCursor();
void death();
void step_1();
void PlayMusic();
void StopMusic();
bool isColliding();

// 碰撞检测
bool isColliding(float x, float y, int x_left, int y_left, int x_right, int y_right) {
    return (x - 5 < x_right && x + 35 > x_left && y - 12 < y_right && y + 50 > y_left);
}

// 播放音乐函数
void PlayMusic() {
    mciSendString(_T("open hundouluo.mp3 alias bkmusic"), NULL, 0, NULL); // 打开音乐文件
    mciSendString(_T("play bkmusic repeat"), NULL, 0, NULL); // 循环播放音乐
}
```

|功能类型|函数声明|函数作用说明|
| --------------| ----------| --------------------------------------------------------------------------------------------------------------------|
|图形绘制相关|​`void DrawButton(Button* btn);`​|用于绘制按钮，传入按钮指针作为参数，推测是在界面上绘制按钮图形|
|鼠标检测相关|​`bool CheckMouse(Button* btn);`​|用于检测鼠标与按钮的交互情况，返回布尔值，判断鼠标是否满足与按钮交互的条件|
|内容展示相关|​`void ShowStory();`​|功能应是展示故事内容，可能是游戏剧情等相关文本展示|
|关卡选择相关|​`void ShowLevelSelection(int* level);`​|用于展示关卡选择界面，传入关卡指针，可能用于显示当前可选关卡及相关信息|
|光标控制相关|​`void HideCursor();`​|作用是隐藏光标，可能用于特定场景下避免光标干扰|
|游戏状态相关|​`void death();`​|用于处理游戏角色死亡相关逻辑，比如播放死亡动画、结束当前游戏进程等|
|游戏步骤相关|​`void step_1();`​|或许是游戏流程中第一步相关的操作函数，执行特定的游戏步骤|
|音乐控制相关|​`void PlayMusic();`​<br />`void StopMusic();`​|​`PlayMusic`​ 用于播放音乐，从代码看是打开并循环播放指定音乐文件；`StopMusic`​ 用于停止音乐播放|
|碰撞检测相关|​`bool isColliding();`​<br />`bool isColliding(float x, float y, int x_left, int y_left, int x_right, int y_right)`​|第一个声明可能是无参的碰撞检测函数；第二个实现了具体的碰撞检测逻辑，通过传入坐标参数，判断是否发生碰撞并返回布尔值|

与此同时，汪世伦对碰撞逻辑进行了深度优化，以确保游戏体验的流畅性。他注意到，在高密度陨石生成的情况下，碰撞检测可能会导致帧率下降，从而影响玩家的操作体验。为此，汪世伦引入了一种空间分区技术，将屏幕划分为多个小区域，仅对相邻区域内的物体进行碰撞检测，从而大幅减少了计算量。此外，他还对陨石的运动轨迹进行了微调，使其更加自然且符合物理规律，避免了因不合理的运动模式引发的意外碰撞。

```cpp
// 清除旧位置（根据运动方向优化清除区域）
clearrectangle(x - abs(dx) - 5, y - abs(dy) - 5,
               x + 30 + abs(dx) + 5, y + 40 + abs(dy) + 5);

// 更新位置
x += dx;
y=y+dy+mg;
// 判断碰撞
int x_left[11]={0,100,200,280,260,500,600,700,700,670,30};
int y_left[11]={300,330,250,350,450,230,200,220,330,400,70};
int x_right[11]={40,140,240,320,300,540,640,740,740,710,50};
int y_right[11]={340,370,290,390,490,270,240,260,370,440,100};
// 添加一个状态标记
bool isRespawning = false;
for(int i = 0; i < 11; i++) {
    if (isColliding(x, y, x_left[i]*10/8, y_left[i]*8/6, x_right[i]*10/8, y_right[i]*8/6)) {
        x = 0.0f, y = 759.0f;
        death_counter=death_counter+1;
        break;
    }
}

if(death_counter>=5){
    death();
}
```

|步骤|代码逻辑|
| ------| ---------------------------------------------------------------------------------------------------------------------------------------------------------|
|1|清除旧位置：使用 `clearrectangle`​ 函数，根据 `x`​、`y`​ 坐标以及 `dx`​、`dy`​（可能是位移量）计算清除区域并清除旧位置。|
|2|更新位置：`x`​ 坐标加上 `dx`​，`y`​ 坐标加上 `dy`​ 与 `mg`​（推测 `mg`​ 可能是重力相关量） 。|
|3|定义碰撞检测相关数组：定义了 `x_left`​、`y_left`​、`x_right`​、`y_right`​ 四个数组，每个数组包含11个元素，可能用于表示不同物体或区域的边界坐标。|
|4|初始化状态标记：定义布尔变量 `isRespawning`​ 并初始化为 `false`​ ，可能用于表示是否处于重生状态。|
|5|碰撞检测循环：通过 `for`​ 循环遍历11个可能的碰撞区域，使用 `isColliding`​ 函数判断是否发生碰撞。如果发生碰撞，将 `x`​ 设为 `0.0f`​，`y`​ 设为 `759.0f`​ ，`death_counter`​ 自增1 ，然后 `break`​ 跳出循环。|
|6|死亡判定：检查 `death_counter`​ 是否大于等于5，如果是则调用 `death()`​ 函数，可能用于处理游戏角色死亡等相关逻辑。|

在音效和氛围营造方面，唐铭阳为游戏添加了背景音乐，进一步提升了沉浸感。他选择了一段低沉而富有节奏感的电子音乐【魂斗罗】，与宇宙主题高度契合，同时通过动态音量调整技术，使音乐在玩家处于紧张时刻时变得更加激昂，而在平静阶段则趋于柔和。这些音效的加入不仅弥补了此前的缺失，还为游戏注入了更多的情感元素，使玩家能够更深刻地感受到游戏的节奏和氛围。

```cpp
void ShowStory() {
    putimage(0, 0, &background);

    settextcolor(WHITE);
    settextstyle(90, 0, _T("黑体"));
    outtextxy(200*17*1.3/6.4, 20*10*1.3/4.8, _T("星际飞碟之旅"));

    settextstyle(40, 0, _T("楷体"));
    const TCHAR* story[] = {
        _T("公元2223年，地球空间站遭到陨石群袭击，"),
        _T("作为精英驾驶员的你，必须驾驶最新型飞碟"),
        _T("穿越危险的陨石带，运送重要物资到空间站。"),
        _T(" "),
        _T("【任务目标】"),
        _T("1. 躲避太空垃圾和陨石"),
        _T("2. 收集能源晶体维持护盾"),
        _T("3. 在氧气耗尽前抵达空间站")
    };

    for (int i = 0; i < sizeof(story) / sizeof(story[0]); i++) { 
        outtextxy(50*17/6.4, (100 + i * 30)*10/4.8, story[i]);
    }

    // 继续按钮
}
```

|步骤|操作内容|目的|
| ------| --------------------------------------------| --------------------------------------------------------------------------------------|
|1|​`putimage(0, 0, &background);`​|在坐标 `(0, 0)`​ 处绘制背景图像|
|2|​`settextcolor(WHITE);`​ <br /> `settextstyle(90, 0, _T("黑体"));`​ <br /> `outtextxy(200*17*1.3/6.4, 20*10*1.3/4.8, _T("星际飞碟之旅"));`​|设置文字颜色为白色，字体样式为黑体、字号 90 ，并在指定坐标处输出标题“星际飞碟之旅”|
|3|​`settextstyle(40, 0, _T("楷体"));`​ <br /> 定义 `story`​ 数组存储故事和任务目标文本|设置文字字体样式为楷体、字号 40 ，并准备存储剧情和任务目标相关文本|
|4|​`for`​ 循环：<br />`for (int i = 0; i < sizeof(story) / sizeof(story[0]); i++) {`​<br /> `outtextxy(50*17/6.4, (100 + i * 30)*10/4.8, story[i]);`​<br /> `}`​|遍历 `story`​ 数组，按一定坐标规则逐行输出数组中的文本内容|
|5|​`// 继续按钮`​（注释部分）|预留继续按钮相关功能，未具体实现|

通过这一阶段的努力，团队成功解决了之前遗留的技术问题，并对游戏的整体体验进行了全方位的优化。这些改进不仅提升了游戏的稳定性，还使其在视觉、听觉和操作层面达到了更高的水准，为最终版本的发布奠定了坚实的基础。

### 日志（四）：功能组装

刘润杰：飞机图片

唐铭阳：关卡拼接

汪世伦：第三关碰撞

刘润杰：飞机图片设计与优化  
刘润杰完成了飞船的视觉设计，初始化美术设计，并根据反馈对飞船图片进行了细节优化。新的飞船设计更加符合游戏主题，采用了流线型外观和炫酷的科技感配色，使其在深邃的宇宙背景中显得格外醒目。此外，还为飞船添加了死亡效果，提升了整体视觉体验。

![image](assets/image-20250402131516-tmr8rtw.png)

唐铭阳：关卡拼接与逻辑实现  
唐铭阳负责将零散的关卡模块整合成一个连贯的游戏流程。通过调整关卡之间的衔接逻辑，他成功实现了从主菜单选择关卡，并初步搭建了第三关的基础框架。同时，他还优化了关卡加载机制，减少了加载时间，提升了游戏流畅度。

```c
#include <stdio.h>
#include <conio.h>
#include <windows.h>
#include <mmsystem.h>  // 添加多媒体头文件
#include <stdlib.h>
#include <graphics.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include <cmath>
#pragma comment(lib, "Winmm.lib")  // 链接多媒体库
#define x1 30
#define y1 30
// 定义窗口的宽度和高度，为 1700 和 1000
#define WINDOW_WIDTH 1700
#define WINDOW_HEIGHT 1000
// 定义圆形的半径
#define CIRCLE_RADIUS 55
// 定义圆形的基准移动速度
#define SPEED 8
// 定义移动圆形的数量
#define MOVING_CIRCLE_COUNT 9
// 定义固定矩形的数量
#define FIXED_RECT_COUNT 3
// 浅蓝色 RGB 值
#define LIGHT_BLUE RGB(173, 216, 230)
```

汪世伦：第三关碰撞检测  
汪世伦专注于第三关的碰撞检测功能，解决了此前存在的误判问题。通过对飞船与陨石、边界墙等物体的碰撞算法进行优化，他显著提高了检测的准确性和实时性，进一步增强了紧张感。

```cpp
// 初始化移动圆形的属性
void initMovingCircles(C circles[], int count) {
    int radius = 400; // 扇形半径
    int minX = WINDOW_WIDTH - CIRCLE_RADIUS - radius; // 扇形起始 x 坐标

    for (int i = 0; i < count; i++) {
        circles[i].radius = CIRCLE_RADIUS;

        // 随机初始化圆形的位置，使其在扇形左边
        circles[i].x = getRandom(0 + CIRCLE_RADIUS, minX);
        circles[i].y = getRandom(0 + CIRCLE_RADIUS, WINDOW_HEIGHT - CIRCLE_RADIUS);

        // 设置圆形的移动方向，避免水平或垂直运动
        int dx_temp, dy_temp;
        do {
            dx_temp = getRandom(SPEED - 2, SPEED + 2);
            if (getRandom(0, 1)) {
                dx_temp = -dx_temp;//随机让移动反向
            }
        }
    }
}
```

|步骤|代码逻辑|
| ------| -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|1|定义函数 `initMovingCircles`​，接受圆形数组 `circles`​ 和圆形数量 `count`​ 作为参数，用于初始化移动圆形的属性 。|
|2|定义变量 `radius`​ 表示扇形半径，值为 `400`​；定义变量 `minX`​ 计算扇形起始 `x`​ 坐标，通过窗口宽度 `WINDOW_WIDTH`​ 减去圆的半径 `CIRCLE_RADIUS`​ 和扇形半径 `radius`​ 得到 。|
|3|使用 `for`​ 循环遍历圆形数组，循环次数为圆形数量 `count`​ 。|
|4|在循环内，首先设置每个圆形的半径为 `CIRCLE_RADIUS`​ 。|
|5|然后通过调用 `getRandom`​ 函数，分别随机初始化每个圆形的 `x`​ 坐标（范围在 `0 + CIRCLE_RADIUS`​ 到 `minX`​ 之间）和 `y`​ 坐标（范围在 `0 + CIRCLE_RADIUS`​ 到 `WINDOW_HEIGHT - CIRCLE_RADIUS`​ 之间），使圆形在扇形左边 。|
|6|接着定义变量 `dx_temp`​ 和 `dy_temp`​ 用于设置圆形移动方向，通过 `do - while`​ 循环，先调用 `getRandom`​ 函数获取在 `SPEED - 2`​ 到 `SPEED + 2`​ 之间的 `dx_temp`​ 值，再通过调用 `getRandom(0, 1)`​ 随机决定是否将 `dx_temp`​ 取反，以此避免水平或垂直运动（不过代码中 `do - while`​ 循环没有 `while`​ 条件部分，属于不完整代码 ）。|

# 日志（五）

刘润杰：二三关的美术设计

汪世伦：障碍物移动

唐铭阳：到达黑洞跳到下一关

**刘润杰 - 二三关美术设计**：

确定二三关美术风格在延续科幻主调基础上，第二关主打“星际废墟”主题已完成废墟场景主体架构搭建，陨石坑、等元素组合错落有致，为玩家操控飞船穿梭其中构建出极具沉浸感的空间。

第三关与黑洞关卡过渡衔接。色彩上采用蓝紫为主

![image](assets/image-20250416133105-uituxwb.png)

**汪世伦 - 障碍物移动**：

攻克了障碍物动态路径规划难题，通过引入物理碰撞检测优化，障碍物间碰撞、反弹效果自然，增加玩家躲闪难度与趣味性。

针对第三关美术、玩法融合，极大丰富游戏挑战层次。经多轮测试，障碍物移动流畅性与挑战性达到预期平衡，未出现异常穿模、运动不协调问题。

![image](assets/image-20250416133046-cmbkw3m.png)

**唐铭阳 - 到达黑洞跳到下一关**：

构建黑洞触发跳转机制核心逻辑，当飞船进入黑洞事件视界范围（以精确到像素级的碰撞判定识别），触发特效过渡。

关卡判定准确，目前跳转成功率、数据传输准确率均达到 100%。

![image](assets/image-20250416133015-xmihbpl.png)

# 日志（六）

刘润杰：游戏功能基本实现，本周为最后优化以及日志详细书写。

汪世伦：游戏功能基本实现，本周为最后优化以及日志详细书写。

唐铭阳：游戏功能基本实现，本周为最后优化以及日志详细书写。

### 回顾与展望：开发经验与未来计划

![image](assets/image-20250416143350-izom034.png)

通过对“飞碟星际之旅”小游戏的开发过程进行回顾，我们总结出了一系列宝贵的经验教训，同时也对未来版本的改进提出了具体的建议。首先，团队在开发初期就明确了分工与目标，这为项目的顺利推进奠定了基础。然而，我们也意识到，在功能开发的过程中，某些模块之间的依赖关系可能导致进度延迟。例如，音效的缺失曾一度影响了游戏的整体体验，这提醒我们在未来的项目中应尽早规划并整合所有关键资源，以避免类似问题的发生。

此外，代码调试是一个贯穿始终的重要环节。在开发过程中，我们多次遇到因代码连接错误而导致的功能失效问题。这表明，建立一套完善的代码审查和测试机制至关重要。未来，我们计划引入自动化测试工具，定期对代码进行检查，从而减少人为失误的可能性，并提高开发效率。

关于未来版本的改进方向，我们计划从以下几个方面入手：一是增强游戏的多样性，例如玩家在闯关的同时能够解锁新飞船；二是优化关卡设计，增加更多动态元素，比如黑洞引力场，以提升游戏的策略性和趣味性；三是进一步完善音效和视觉效果，例如通过音效技术增强空间感，从而为玩家带来更加身临其境的体验。

总之，“星际飞碟之旅”小游戏的开发不仅是对我们技术能力的一次全面检验，也为我们积累了丰富的实战经验。未来，我们将继续秉持精益求精的态度，不断优化和完善游戏，力求为玩家提供更高品质的娱乐体验，期待你的到来

‍
